<!DOCTYPE html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/1.33.1/plotly.min.js"></script>
</head>
<body>
    Launching a ball from height y, predicting it lands at site x. Using kinematic equations to hit a target 15m away
    What is the maximum entropy of the model?
    <div>
        Height (m):<input id='h' type='number' value=10 id='height'><br>
        Initial Height (m):<input id='d' type='number' value=5.62 id='height'>We will regress away from the initial height which should be the predicted height for the target distance (15m in this case)<br> 
        launcherError (1/%):<input  id='e' type='number' value=0.1 id='height'>With added error Math.random()*-0.6*launcherError to simulate a real ramp<br> 
        nTrials (integer):<input  id='n' type='number' value=1000 id='height'><br>
        Entropy histogram number of bins:<input id='b' type='number' value=25 id='height'><br>
        <button id='submit'>Calculate</button>
    </div>
    <hr>
    Prediction and Actual
    <div id='a' style='width:100%;'></div>
    <hr>
    Probability Densities 
    <div id='b' style='width:100%;'></div>
    <hr>
    Relative Error vs Information Entropy (Uncertainty) | Most occurring (maximum) entropy: <span id='ent'></span> Area under hist curve: <span id='areaent'></span>
    <div id='c' style='width:100%;'></div>
    <script>
      

        //find the relative error of predicted results
        function relError(actual=[],forecast=[]) {
            if(actual.length !== forecast.length) throw new Error('Input arrays of same length!');
            let i = actual.length;
            let d = []; //relative errors
            for(let j = 0; j<i; j++) {
                d.push(Math.abs((actual[j] - forecast[j])/actual[j]));
            }

            return d;
        }

        function mean(arr) {
            var sum = arr.reduce((prev,curr)=> curr += prev);
            return sum / arr.length;
        }

        function sum(arr=[]){
            if (arr.length > 0){
                var sum = arr.reduce((prev,curr)=> curr += prev);
            return sum;
            } else {
                return 0;
            }
        }
        
        function variance(arr) { //Variance of 1D input arrays of length n
            var m = mean(arr);
            return arr.reduce((a,b) => a + ((b - m)**2), 0)/arr.length;
        }

        function histogram(arr=[], binSize=1, nBins=undefined) { //return a histogram of the array, use nBins to override binSize 
            let copy = [...arr]; 
            copy.sort(function(a, b){return a - b}); //ascending sort
            let binStart = Math.min(...copy);
            if(typeof nBins === 'number') {
                let binEnd = Math.max(...copy);
                binSize = Math.abs((binEnd - binStart) / (nBins-1));
            } 
            let j = binStart;
            let binx = [];
            let biny = [];
            for(let i = 0; i < copy.length; i++) {
                let binidx = binSize*j;
                if(copy[i] > binStart+binidx) { 
                    j++; 
                    binidx+=binSize; 
                    let binmin = binStart+binidx;
                    let binmid = binmin + binidx*0.5;
                    binx.push(binmid);
                    biny.push(0);
                }
                biny[biny.length-1]++;
            }

            return [binx,biny];
        }


        //Get probability densities for the samples, set a cutoff to avoid obscenely small numbers
        function normalDistribution(samples=[], normalize=true, cutoff = 0.00001) {
            let m = mean(samples);
            let vari = variance(samples);
            let nSamples = samples.length;

            let probabilities = [];

            let denom = 1/(Math.PI*2*vari);
            let _variance = 1/vari;
            let sum = 0; //for normalization
            for (let i = 0; i < nSamples; i++) {
                let px = Math.exp(-0.5*Math.pow((samples[i]-m)*_variance,2))*denom;
                probabilities.push(px);
                sum += px;
            }
            if(normalize) {
                let _sum = 1/sum;
                probabilities = probabilities.map((x) => {let norm = x*_sum; if(norm < cutoff) norm = 0; return norm;});
            }
        
            return probabilities;
        }

        function expectedValue(samples=[],probabilities=normalDistribution(samples)) {
            return samples.reduce((sum,item,idx) => sum + item*probabilities[idx]);
        }

        //moment about the origin (statistics)
        function originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) {
            return samples.reduce((sum,item,idx) => sum + Math.pow(item,order)*probabilities[idx]);
        }

        //moment about the population mean (statistics)
        function centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) {
            let m = this.mean(samples);
            return samples.reduce((sum,item,idx) => sum + Math.pow((item-m),order)*probabilities[idx]/samples.length);
        }

        //return in natural units (base e)
        function informationEntropy(probabilities=[]) {
            let entropy = [];
            let len = probabilities.length;
            for(let i = 0; i < len; i++) {
                let ent = probabilities[i]*Math.log(probabilities[i]);
                if(isNaN(ent)) ent = 0;
                entropy.push(ent);
            }

            return entropy;
        }

        function originMoment(samples=[],order=1) {
            let m = mean(samples);
            let expectedValues = samples.map(x => x-m);
            let l = samples.length;
        }

        function maxEntDistribution(samples=[]) {
            /*
                To find the maxEnt distribution,
                solve for the lagrangians 
            */
        }



        function calculateTrials() {
            let heights = [];
            let predictedLandings = [];
            let actualLandings = [];
            let d = []; // relative error
            let pEnt = [];
            let pDist = []; //probability density of forecast
            let aDist = []; //probability density of actual
            let pEntHist = [[],[]];
            let maxEnt = 0;
            let ct = 0;


            let fallHeight = parseFloat(document.getElementById('h').value); //meters
            let launcherError = parseFloat(document.getElementById('e').value);
            let ntrials = parseInt(document.getElementById('n').value);
            let pEntHistBin = parseInt(document.getElementById('b').value);
            let h0 = parseFloat(document.getElementById('d').value); //initial launcher start
            let g = 9.81; //acceleration due to gravity

            //launch a ball from a frictionless ramp of height y0, from a height of y1, how far away does it land?
            function estLauncherLandingDist(launcherHeight=5, fallHeight=10) {
                let t1 = Math.sqrt(2*fallHeight/g);
                let x1 = g*t1*Math.sqrt(2*launcherHeight/g);
                return x1;
            }

            while(ct < ntrials) {

                let launcherHeight = h0 + (Math.random()-1)/(ct+1);
                let launchDistance = estLauncherLandingDist(launcherHeight,fallHeight);

                heights.push(launcherHeight);
                predictedLandings.push(launchDistance);
                actualLandings.push(launchDistance+(Math.random()-.6)*launcherError); //10% error with slightly negative bias (because a real ramp would not be frictionless + human error)
                ct++;
            }
            
            d = relError(actualLandings,predictedLandings);
            pDist = normalDistribution(predictedLandings);
            aDist = normalDistribution(actualLandings);
            pEnt = informationEntropy(d);
            pEntHist = histogram(pEnt,undefined,pEntHistBin);

            console.log('drop heights',heights);
            console.log('predicted landings',predictedLandings);
            console.log('real landings',actualLandings);
            console.log('predicted distribution',pDist);
            console.log('actual distribution',aDist);
            console.log('relative error entropy',pEnt);


            //Now find the Maximum Entropy Distribution
            maxEnt = pEntHist[0][pEntHist[1].indexOf(Math.max(...pEntHist[1]))];
            maxEntArea = sum(pEntHist[1].map((v, i) => {return v*pEntHist[0][i]}));

            document.getElementById('ent').innerHTML = maxEnt.toFixed(5);
            document.getElementById('areaent').innerHTML = maxEntArea.toFixed(5);
            console.log('max ent (negative)',maxEnt);
            console.log(pEntHist,'entropy histogram');


            let data = [
                [
                    {
                        x: predictedLandings,
                        y: heights,
                        mode: 'markers',
                        type:'scatter',
                        marker: {
                            color: "rgba(255,100,100, 1)"
                        },
                        name: "Predicted",
                        //xbins: {  size: 0.01  }
                    },{
                        x: actualLandings,
                        y: heights,
                        mode: 'markers',
                        type:'scatter',
                        marker: {
                            color: "rgba(100,255,100, 1)"
                        },
                        name: "Actual",
                        //xbins: {  size: 0.01  } 
                    }
                ],
                [
                    {
                        x: predictedLandings,
                        y: pDist,
                        mode: 'markers',
                        type:'scatter',
                        marker: {
                            color: "rgba(255,100,255, 1)"
                        },
                        name: "Prediction Probability Density (Forced Gaussian)",
                        //xbins: {  size: 0.01  } 
                    },
                    {
                        x: actualLandings,
                        y: aDist,
                        mode: 'markers',
                        type:'scatter',
                        marker: {
                            color: "rgba(100,100,255, 1)"
                        },
                        name: "Actual Probability Density (Forced Gaussian)",
                        //xbins: {  size: 0.01  } 
                    }
                ],
                [
                    {
                        x: pEntHist[0],
                        y: pEntHist[1],
                        mode: 'markers',
                        type:'scatter',
                        marker: {
                            color: "rgba(100,255,100, 1)"
                        },
                        name: "Entropy histogram",
                        //xbins: {  size: 0.01  } 
                    }
                ]
            ];

            let config = { 
                scrollZoom: true, 
                responsive: true, 
            }

            console.log(data[1])
            Plotly.newPlot("a",data[0],undefined,config);
            Plotly.newPlot("b",data[1],undefined,config);
            Plotly.newPlot("c",data[2],undefined,config);

        }

        document.getElementById('submit').onClick = () => {
            calculateTrials();
        }

        calculateTrials();


    </script>
</body>