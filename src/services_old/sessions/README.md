### SessionStreaming

This implements efficient game and user streaming tools for creating arbitrary multiplayer/multiuser sessions. Includes basic moderation of game rooms and ways to easily set up update scripts for incoming streams.

```

//create a session class to enable multiplayer tools
let session = new SessionStreaming(
    WebsocketClient,
    userinfo = {_id:'user123915485'}, //supply user info, just needs an id really or it will make one for you
    socketId 
);

let sessioninfo = await session.createSession(
    	options={
			type:'room', //'user','room','hostroom' 
			appname:`app${Math.floor(Math.random()*1000000000000)}`, //app name for the session (to create lookup tables based on the application name)
			//id:'user123', //alternatively supply a user id to subscribe to
			object:{key1:0}, //data structure the outgoing datastream (see DataStreaming class)
			settings:{
                keys:['key1'] //will be autogenerated if none supplied and sets the stream propnames for users in the session
            } //settings for the outgoing datastream (see DataStreaming class)
		}, 
		callback=(result)=>{}, 	//runs once on return
		onupdate=(result)=>{}, 	//per-update responses e.g. sequential data operations
		onframe=(result)=>{}   	//frame tick responses e.g. frontend updates
);

//rooms send all user data to all other users, based on propnames

//hostrooms only send one user's data to all users, while the host still receives all users' data. 

let usersessioninfo = await session.subscribeToUser(
    userId,
    propnames=['key'],
    callback=(result)=>{}, 	//runs once on return
    onupdate=(result)=>{}, 	//per-update responses e.g. sequential data operations
    onframe=(result)=>{}   	//frame tick responses e.g. frontend updates
);

let info = await session.subscribeToSession(
    sessionId, //session id to subscribe to
    defaultStreamSetup=true,    //sets up a default datastreaming object which you can update with session.datastream.updateStreamData(info.data.appname,{...propnames:'newdata'}), alternatively to be handled yourself
    callback = (result) => {}   //user id to subscribe to session (yours by default)
    onupdate = (result) => {}, 	//per-update responses e.g. sequential data operations
    onframe = (result) => {}   	//frame tick responses e.g. frontend updates
)

session.unsubscribe(
    sessionId, //session id to unsubscribe from
    userId, //user id to unsubscribe from session (yours by default)
    callback = (result) => {} //frame tick responses e.g. frontend updates
); //session.kick is an alias

let settings = await session.setSessionSettings(
    sessionId, //session to modify props for
    settings={}, //props to add or replace in session (careful!). Users will be updated next loop
    callback = (result) => {} //frame tick responses e.g. frontend updates
);

let result = await session.deleteSession(
    sessionId, //session to delete
    callback = (result) => {} //frame tick responses e.g. frontend updates
)

let result2 = session.makeHost(
    userId, //user to make host
    sessionId, //session to make user host of
    callback = (result) => {} //frame tick responses e.g. frontend updates
) //makeAdmin, makeOwner, makeModerator, removeAdmin, removeModerator, banUser, unbanUser

//manual session updating:

session.updateUserStream(
    sessionId, //session to trigger an update to the listening user for
    callback = (result) => {} //frame tick responses e.g. frontend updates
)

session.updateSessionUsers(
    sessionId, //session to trigger an update to all users for
    callback = (result) => {} //frame tick responses e.g. frontend updates
)

```
